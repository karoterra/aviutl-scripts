@頂点追加
--track0:X1,-1000,1000,-50,0.01
--track1:Y1,-1000,1000,0,0.01
--track2:X2,-1000,1000,50,0.01
--track3:Y2,-1000,1000,0,0.01

local n = #KaroterraDynamicPolygon
KaroterraDynamicPolygon[n+1] = obj.track0
KaroterraDynamicPolygon[n+2] = obj.track1
KaroterraDynamicPolygon[n+3] = obj.track2
KaroterraDynamicPolygon[n+4] = obj.track3


@描画
--track0:ライン幅,0,1000,10
--track1:頂点数数,2,20,20,1
--track2:ラインA,0,100,100
--track3:フィルA,0,100,100
--dialog:ライン色/col,color=0xffffff;フィル/col,color2=0x000000;角(0 - 3),p0=3;シャープ限界(>0),p1=5;端(0 - 2),p2=0;フィルモード(0 - 2),p7=2;ラインAA/chk,p3=1;フィルAA(0 - 2),p8=1;頂点表示/chk,p4=0;頂点色/col,color3=0xff0000;頂点サイズ,p5=10;頂点A(0 - 100),p6=100;中心(0 - 2),p9=0;座標系(0 - 4),p10=0
--check0:閉じる,1
--[[
  A はアルファ(不透明度)、AAはアンチエイリアス
  角
    0: 角処理なし
    1: 丸
    2: ベベル
    3: シャープ
  シャープ限界
    角がシャープの時、ライン幅に対してどれだけ角を尖らせるか
  端
    0: フラット
    1: 丸
    2: 四角
  フィルモード
    0: 無効
    1: Crossing Number algorithm
    2: Winding Number algorithm
  フィルAA
    0: 無効
    1: アンチエイリアスその1
    2: アンチエイリアスその2
  中心
    0: オブジェクト座標が中心
    1: 多角形を含む最小の矩形の中心が中心
    2: 多角形の重心が中心
  座標系
    0: 直交座標(絶対)
    1: 直交座標(相対)
    2: 曲座標(絶対)
    3: 極座標(相対,偏角リセット)
    4: 極座標(相対,偏角持越し)
]]

local lw = obj.track0 / 2
local num = obj.track1 * 2
local corner = p0
local sharpLimit = p1
local edge = p2
local antialias = p3
local close = obj.check0
local strokeAlpha = obj.track2 / 100
local fillAlpha = obj.track3 / 100
local vertexAlpha = p6 / 100
local showVertex = p4 == 1 and vertexAlpha > 0
local vertexSize = p5
local fillMode = p7
local fillAntialias = p8
local centerMode = p9
local coordType = p10
local kdp = KaroterraDynamicPolygon
local libKDP = require("KaroterraDynamicPolygon")

if #kdp < num then
  num = #kdp
end
if num == 4 then
  close = false
end

-- 関数定義
function rotate(x, y, theta)
  local cos = math.cos(theta)
  local sin = math.sin(theta)
  return x*cos-y*sin, x*sin+y*cos
end

function calcLineCoef(x1, y1, x2, y2)
  local a = (y2 - y1) / (x2 - x1 + 1e-7)
  local b = y1 - a * x1
  return a, b
end

function calcIntersection(a1, b1, a2, b2)
  local x = (b2 - b1) / (a1 - a2 + 1e-7)
  local y = a1 * x + b1
  return x, y
end

function radDiff(x, y)
  local z = x - y
  if z > math.pi then
    z = z - 2 * math.pi
  elseif z < -math.pi then
    z = z + 2 * math.pi
  end
  return z
end

function makeLine(x1, y1, x2, y2)
  local theta = math.atan2(y2-y1, x2-x1)
  local dx, dy = rotate(0, lw, theta)
  local line = {
    x1, y1, x2, y2, theta,
    x1+dx,y1+dy, x1-dx,y1-dy, x2-dx,y2-dy, x2+dx,y2+dy
  }
  return line
end

function drawline(l)
  obj.drawpoly(l[6],l[7],0, l[8],l[9],0, l[10],l[11],0, l[12],l[13],0)
end

function drawCorner(l1, l2)
  if corner == 1 then
    obj.load("figure", "円", color, lw*2+2)
    obj.draw(l1[3], l1[4])
  elseif corner == 2 then
    obj.load("figure", "四角形", color, 1)
    if radDiff(l2[5], l1[5]) > 0 then
      obj.drawpoly(l1[10],l1[11],0, l2[8],l2[9],0, l1[12],l1[13],0, l2[6],l2[7],0)
    else
      obj.drawpoly(l1[10],l1[11],0, l2[6],l2[7],0, l1[12],l1[13],0, l2[8],l2[9],0)
    end
  elseif corner == 3 then
    obj.load("figure", "四角形", color, 1)
    if radDiff(l2[5], l1[5]) > 0 then
      local a1, b1 = calcLineCoef(l1[8], l1[9], l1[10], l1[11])
      local a2, b2 = calcLineCoef(l2[8], l2[9], l2[10], l2[11])
      local x3, y3 = calcIntersection(a1, b1, a2, b2)
      local len = math.sqrt((l1[3]-x3)^2 + (l1[4]-y3)^2)
      if len / lw <= sharpLimit then
        obj.drawpoly(l1[3],l1[4],0, l1[10],l1[11],0, x3,y3,0, l2[8],l2[9],0)
      else
        obj.drawpoly(l1[10],l1[11],0, l2[8],l2[9],0, l1[12],l1[13],0, l2[6],l2[7],0)
      end
    else
      local a1, b1 = calcLineCoef(l1[6], l1[7], l1[12], l1[13])
      local a2, b2 = calcLineCoef(l2[6], l2[7], l2[12], l2[13])
      local x3, y3 = calcIntersection(a1, b1, a2, b2)
      local len = math.sqrt((l1[3]-x3)^2 + (l1[4]-y3)^2)
      if len / lw <= sharpLimit then
        obj.drawpoly(l1[3],l1[4],0, l2[6],l2[7],0, x3,y3,0, l1[12],l1[13],0)
      else
        obj.drawpoly(l1[10],l1[11],0, l2[6],l2[7],0, l1[12],l1[13],0, l2[8],l2[9],0)
      end
    end
  end
end

-- 座標系の変換
if coordType == 1 then  -- 直交座標(相対)
  for i = 3, num-1, 2 do
    kdp[i] = kdp[i] + kdp[i-2]
    kdp[i+1] = kdp[i+1] + kdp[i-1]
  end
elseif coordType == 2 then -- 極座標
  for i = 1, num-1, 2 do
    local r, theta = kdp[i], math.rad(kdp[i+1])
    kdp[i], kdp[i+1] = r * math.cos(theta), r * math.sin(theta)
  end
elseif coordType == 3 then -- 極座標(相対,偏角リセット)
  local r, theta = kdp[1], math.rad(kdp[2])
  kdp[1], kdp[2] = r * math.cos(theta), r * math.sin(theta)
  for i = 3, num-1, 2 do
    r, theta = kdp[i], math.rad(kdp[i+1])
    kdp[i], kdp[i+1] = r*math.cos(theta) + kdp[i-2], r*math.sin(theta) + kdp[i-1]
  end
elseif coordType == 4 then -- 極座標(相対,偏角持越し)
  local r, theta = kdp[1], math.rad(kdp[2])
  kdp[1], kdp[2] = r * math.cos(theta), r * math.sin(theta)
  for i = 3, num-1, 2 do
    r, theta = kdp[i], theta + math.rad(kdp[i+1])
    kdp[i], kdp[i+1] = r*math.cos(theta) + kdp[i-2], r*math.sin(theta) + kdp[i-1]
  end
end

-- 中心
local minX, maxX, minY, maxY = kdp[1], kdp[1], kdp[2], kdp[2]
local accX, accY = kdp[1], kdp[2]
for i = 3, num-1, 2 do
  if kdp[i] < minX then
    minX = kdp[i]
  elseif kdp[i] > maxX then
    maxX = kdp[i]
  end
  if kdp[i+1] < minY then
    minY = kdp[i+1]
  elseif kdp[i+1] > maxY then
    maxY = kdp[i+1]
  end
  accX = accX + kdp[i]
  accY = accY + kdp[i+1]
end

local cx, cy = (minX + maxX) / 2, (minY + maxY) / 2
local gx, gy = accX / (num / 2), accY / (num / 2)
for i = 1, num-1, 2 do
  kdp[i] = kdp[i] - cx
  kdp[i+1] = kdp[i+1] - cy
end


-- 描画する直線の整理
local lines = {}
for i = 1, num-3, 2 do
  lines[#lines+1] = makeLine(kdp[i], kdp[i+1], kdp[i+2], kdp[i+3])
end
if close then
  lines[#lines+1] = makeLine(kdp[num-1], kdp[num], kdp[1], kdp[2])
end

-- フレームバッファサイズの決定
local w = math.max(maxX - cx, cx - minX) * 2
local h = math.max(maxY - cy, cy - minY) * 2
local margin = lw * 2
if corner == 3 then
  margin = math.max(margin, lw * sharpLimit * 2)
end
if showVertex then
  margin = math.max(margin, vertexSize)
end
w, h = w + margin, h + margin

-- 描画
obj.setoption("antialias", antialias)
obj.setoption("drawtarget", "tempbuffer", w, h)

-- 直線
obj.setoption("blend", "alpha_add")
obj.load("figure", "四角形", color, 1)
for i = 1, #lines do
  drawline(lines[i])
end
-- 角
for i = 1, #lines-1 do
  drawCorner(lines[i], lines[i+1])
end
if close then
  drawCorner(lines[#lines], lines[1])
end
-- 端
if not close and edge == 1 then
  obj.load("figure", "円", color, lw*2+2)
  obj.draw(lines[1][1], lines[1][2])
  obj.draw(lines[#lines][3], lines[#lines][4])
elseif not close and edge == 2 then
  obj.load("figure", "四角形", color, 1)
  local l = lines[1]
  local dx1, dy1 = rotate(-lw, lw, l[5])
  local dx2, dy2 = rotate(-lw, -lw, l[5])
  obj.drawpoly(l[1]+dx1,l[2]+dy1,0, l[1]+dx2,l[2]+dy2,0, l[8],l[9],0, l[6],l[7],0)
  l = lines[#lines]
  dx1, dy1 = rotate(lw, -lw, l[5])
  dx2, dy2 = rotate(lw, lw, l[5])
  obj.drawpoly(l[3]+dx1,l[4]+dy1,0, l[3]+dx2,l[4]+dy2,0, l[12],l[13],0, l[10],l[11],0)
end

obj.copybuffer("cache:stroke", "tmp")

obj.setoption("blend", 0)
obj.setoption("drawtarget", "tempbuffer", w, h)
obj.load("tempbuffer")
local data, buf_w, buf_h = obj.getpixeldata()
libKDP.fillPoly(data, buf_w, buf_h, kdp, num, color2, fillMode, fillAntialias)
obj.putpixeldata(data)
obj.draw(0, 0, 0, 1, fillAlpha)
obj.copybuffer("obj", "cache:stroke")
obj.draw(0, 0, 0, 1, strokeAlpha)

-- 頂点
if showVertex then
  obj.load("figure", "円", color3, vertexSize)
  for i = 1, num, 2 do
    obj.draw(kdp[i], kdp[i+1], 0, 1, vertexAlpha)
  end
end

obj.setoption("drawtarget", "framebuffer")
obj.load("tempbuffer")
if centerMode == 1 then
  obj.ox = cx
  obj.oy = cy
elseif centerMode == 2 then
  obj.ox = gx
  obj.oy = gy
  obj.cx = obj.cx + gx - cx
  obj.cy = obj.cy + gy - cy
else
  obj.cx = obj.cx - cx
  obj.cy = obj.cy - cy
end
